

--module Ai where

--height = 6
--width = 7
--colList = [0..(width - 1)]

--data Piece = Me | Them deriving Eq
--type Pieces = [Piece]
--type Col = [Piece]
--type Board = [Col]
--type Move = (Maybe ColNo, Score)
--type ColNo = Int
--type Score = Int
--type Depth = Int
--type EvalFn = Board -> Piece -> Score

--solve :: Board -> Depth -> Maybe ColNo
--solve board depth = fst $ negamax board (cycle [Me, Them]) depth

--negamax :: Board -> Pieces -> Depth -> Move
--negamax board (piece:_) 0 = (Nothing, evaluate board piece)
--negamax board (piece:pieces) depth = middle [(Just colNo, score) | (colNo, score) <- scores, score == (maximum $ map (snd) scores)]
--    where scores = map (\(colNo, board') -> (colNo, negate $ snd $ negamax board' pieces (depth - 1))) $ mapAdd board piece

--evalFns :: [EvalFn]
--evalFns = [ evalH (width - 3)
--          , evalV width
--          , evalD1 (width - 3)
--          , evalD2 (width - 3)]

--evaluate :: Board -> Piece -> Score
--evaluate board view = sum $ map (\f -> f board view) evalFns

--evalV :: Int -> EvalFn
--evalV 0 _ _ = 0
--evalV hor (col:cols) view = (evalV' (col:cols) view) + (evalV (hor - 1) cols view)

--evalV' :: Board -> Piece -> Score
--evalV' ([]:cols) _ = 0
--evalV' ((piece:pieces):cols) view | piece == view = (evalV' pieces:cols view) + (score pieces piece)
--                                  | otherwise = (evalV' pieces:cols view) - (score pieces piece)

--score :: [Piece] -> Piece -> Score
--score [] _ = 1
--score [piece:pieces] match | piece == match = 7 * score pieces match
--                           | otherwise = 0

--evalH :: Int -> EvalFn
--evalH 0 _ _ = 0
--evalH hor (col:cols) view = (evalH' (col:cols) view) + (evalH (hor - 1) cols view)

----TODO
--evalH' :: Board -> Piece -> Score
--evalH' _ _ = 0

--evalD1 :: Int -> EvalFn
--evalD1 _ _ _ _ = 0

--evalD2 :: Int -> EvalFn
--evalD2 _ _ _ _ = 0

--{-
--evaluate = sum forall sets: if unique me then colNo^(#mineInRow - 1) else if unique them then -colNo^(#theirsInRow - 1)
---}

--middle :: [a] -> a
--middle [x] = x
--middle (x:_) = x
--middle xs = middle $ tail $ init xs

--add :: Board -> Piece -> ColNo -> Maybe Board
--add (col:cols) piece 0 | length col >= height = Nothing
--                       | otherwise = Just ((col ++ [piece]):cols)
--add (col:cols) piece colNo = fmap (col:) (add cols piece (colNo - 1))

--mapAdd :: Board -> Piece -> [(ColNo, Board)]
--mapAdd board piece = [(colNo, x) | (colNo, Just x) <- zip colList $ map (add board piece) colList]
